package com.bftcom.docgenerator.ingest

import com.bftcom.docgenerator.configprops.GitHubProps
import com.bftcom.docgenerator.domain.application.Application
import com.bftcom.docgenerator.git.github.GitHubCheckoutService
import com.bftcom.docgenerator.graph.api.GraphBuilder
import com.bftcom.docgenerator.graph.model.BuildResult
import com.bftcom.docgenerator.repo.ApplicationRepository
import org.eclipse.jgit.api.Git
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import java.nio.file.Path
import java.time.Duration
import java.time.OffsetDateTime

@Service
class GitHubIngestOrchestrator(
    private val git: GitHubCheckoutService,
    private val ghProps: GitHubProps,
    private val appRepo: ApplicationRepository,
    private val graphBuilder: GraphBuilder,
) {

    private val log = LoggerFactory.getLogger(javaClass)

    /**
     * 1. –ö–ª–æ–Ω–∏—Ä—É–µ—Ç –∏–ª–∏ –æ–±–Ω–æ–≤–ª—è–µ—Ç —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π GitHub
     * 2. –ù–∞—Ö–æ–¥–∏—Ç –∏–ª–∏ —Å–æ–∑–¥–∞—ë—Ç Application –ø–æ –∫–ª—é—á—É (appName)
     * 3. –°—Ç—Ä–æ–∏—Ç –≥—Ä–∞—Ñ —Å –ø–æ–º–æ—â—å—é GraphBuilder
     */
    @Transactional
    fun runOnce(): IngestSummary {
        // --- 1) –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å appName –∏ checkoutDir ---
        val appName = extractAppName(ghProps.repoUrl)
        val localPath: Path = Path.of(ghProps.basePath, appName)

        // --- 2) –∫–ª–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ / –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è ---
        val actualPath = git.checkoutOrUpdate(
            repoUrl = ghProps.repoUrl,
            branch = ghProps.branch,
            token = ghProps.token,
            username = ghProps.username,
            password = ghProps.password,
            checkoutDir = localPath
        )
        log.info("‚úÖ Repo checked out at {}", actualPath)

        // --- 3) –∏–∑–≤–ª–µ–∫–∞–µ–º —Ç–µ–∫—É—â–∏–π HEAD SHA ---
        val headSha = try {
            Git.open(actualPath.toFile()).use { g -> g.repository.resolve("HEAD")?.name }
        } catch (e: Exception) {
            log.warn("Cannot read HEAD SHA: ${e.message}")
            null
        }

        // --- 4) ensure Application ---
        val parsed = RepoUrlParser.parse(ghProps.repoUrl)
        val app = (appRepo.findByKey(appName)
            ?: Application(
                key = appName,
                name = parsed.name ?: appName,
                repoUrl = ghProps.repoUrl,
                repoProvider = parsed.provider,
                repoOwner = parsed.owner,
                repoName = parsed.name,
                defaultBranch = ghProps.branch,
            )).apply {
            repoUrl = ghProps.repoUrl
            repoProvider = parsed.provider
            repoOwner = parsed.owner
            repoName = parsed.name
            lastCommitSha = headSha
            lastIndexStatus = "running"
            lastIndexedAt = OffsetDateTime.now()
            updatedAt = OffsetDateTime.now()
        }

        val saved = appRepo.save(app)
        log.info("üìá Using application id={} key={}", saved.id, saved.key)

        // --- 5) —Å–±–æ—Ä–∫–∞ –≥—Ä–∞—Ñ–∞ ---
        val build: BuildResult = try {
            graphBuilder.build(saved, actualPath).also {
                saved.lastIndexStatus = "success"
                saved.lastIndexedAt = OffsetDateTime.now()
                appRepo.save(saved)
            }
        } catch (e: Exception) {
            saved.lastIndexStatus = "failed"
            saved.lastIndexError = e.message
            saved.lastIndexedAt = OffsetDateTime.now()
            appRepo.save(saved)
            throw e
        }

        val took = Duration.between(build.startedAt, build.finishedAt)
        log.info("üì¶ Build done: nodes={}, edges={}, chunks={}, took={} ms",
            build.nodes, build.edges, build.chunks, took.toMillis())

        // --- 6) –∏—Ç–æ–≥ ---
        return IngestSummary(
            appKey = saved.key,
            repoPath = actualPath.toString(),
            headSha = headSha,
            nodes = build.nodes,
            edges = build.edges,
            chunks = build.chunks,
            startedAt = build.startedAt,
            finishedAt = build.finishedAt,
            tookMs = took.toMillis()
        )
    }

    /** –ò–∑–≤–ª–µ–∫–∞–µ—Ç –∏–º—è –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –∏–∑ URL (–Ω–∞–ø—Ä–∏–º–µ—Ä org/repo.git ‚Üí repo) */
    private fun extractAppName(repoUrl: String): String {
        val name = repoUrl.substringAfterLast('/').removeSuffix(".git")
        return if (name.isBlank()) "unknown-app" else name
    }
}
